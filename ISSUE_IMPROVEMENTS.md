# 구현 과정에서의 이슈, 개선점, 좋은점

## 1. React-like 라이브러리 관련

### 구현 과정에서 발생한 이슈, 현재 구현에서 발생할 수 있는 문제점

1. Reconciler의 성능 문제
  - diffing 알고리즘이 전체 VNode를 비교하여 비효율적
  - 리스트 업데이트 시 key 기반 최적화가 있지만, 중간 삽입/삭제 시 성능 저하 가능

2. 메모리 관리 문제(해결)
  - unmount 시 이벤트 리스너가 일부 edge case에서 제거되지 않을 가능성 존재
  - 컴포넌트 인스턴스 삭제 시, hooks 상태가 올바르게 해제되지 않는 문제 발생 가능

### 향후 발전시키거나 개선할 수 있는 부분

1. 성능 최적화
  - 변경된 부분만 추적하는 효율적인 diffing 알고리즘 구현
  - 컴포넌트 레벨 메모이제이션(React.memo 유사) 구현
  - useCallback hook 구현

### 좋은 점

1. 단순하면서도 직관적인 Reconciler 구조
  - React와 유사한 방식으로 작동하며, 클래스형 및 함수형 컴포넌트 모두 지원
  - Text 노드와 DOM 요소 구분
  - React-like hooks 구현(useState, useEffect, useMemo, useRef 등)

2. 효율적인 이벤트 핸들링과 메모리 관리
  - addEventListener/removeEventListener를 사용한 이벤트 처리
  - unmount 시 이벤트 리스너와 컴포넌트 인스턴스 정리
  - ref를 통한 DOM 요소 참조 관리


## 2. 가상화 로직 관련

### 구현 과정에서 발생한 이슈, 현재 구현에서 발생할 수 있는 문제점

1. expandItems 관련 이슈
  - 초기에 로컬 상태로 관리했다가 컨트롤(펼치기/접기) 구현이 복잡해지고 상태 공유를 위한 props drilling이 필요. TodoItem CRUD 시 리렌더링을 제어하기 복잡하여 전역 상태로 관리하도록 변경함
2. 성능 관련 이슈
  - findItemInTree 함수가 매번 전체 트리를 순회하여 깊이가 깊은 트리에서 성능 저하 발생
  - flattenedItems 계산 시 매번 전체 트리를 새로 구성하는 오버헤드 발생
  - 대규모 트리 구조에서 flattenedItems가 과도한 메모리 사용
3. 스크롤 관련 이슈
  - 프로그래밍 방식 스크롤의 문제: scrollToIndex 실행과 totalHeight 계산 타이밍 불일치로 인한 문제

### 향후 발전시키거나 개선할 수 있는 부분

1. 성능 관련 이슈
  - Map 자료구조 등을 활용한 최적화 필요
  - 윈도우 크기에 맞는 부분만 flatten하는 최적화 필요

2. 스크롤 관련 이슈
  - 스크롤 이벤트 스로틀링/디바운싱 적용
  - 프로그래밍 방식 스크롤 구현

### 좋은 점

1. 효율적인 가상화 구현
  - 버퍼 기반의 렌더링으로 성능 최적화
  - 필요한 아이템만 렌더링하여 DOM 노드 수 최소화
  - 끊김 없는 렌더링 경험

2. 유연한 아키텍처
  - 관심사 분리 잘 되어있음
  - 재사용 가능한 훅 기반 설계


## 3. API 관련

### 구현 과정에서 발생한 이슈, 현재 구현에서 발생할 수 있는 문제점

1. 성능 이슈
  - 대량의 데이터 요청 시 응답 지연(해결)
  - 캐싱 전략 부재
  - 큰 페이로드로 인한 네트워크 부하(해결)

2. 에러 처리
  - 네트워크 타임아웃 처리 부재

### 향후 발전시키거나 개선할 수 있는 부분

1. 성능 최적화
  - 페이지네이션 구현
  - 캐싱 전략 도입 (React Query 등)
  - 요청 디바운싱/쓰로틀링 적용

2. 에러 처리 강화
  - 통합된 에러 처리 시스템 구축
  - 재시도 메커니즘 구현

### 좋은 점

1. 배치 처리 지원
  - 다중 항목 업데이트/삭제 지원
  - 서버 부하 감소
  - 네트워크 요청 최소화

2. 성능 최적화
  - 페이로드 최적화 (필요한 필드만 요청, 압축)
  - Map 자료 구조를 활용한 조회 최적화

3. 사용자 경험
  - AbortSignal을 통한 요청 취소 지원

4. 타입스크립트 활용
  - 타입 안정성 확보
  - 유지보수성 개선
